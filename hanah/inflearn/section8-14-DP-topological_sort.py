'''
# 위상정렬(토폴로지 정렬)

위상정렬은 어떤 일을 하는 순서를 찾는 알고리즘입니다.
각각의 일의 선후관계가 복잡하게 얽혀있을 때 각각 일의 선후관계를 유지하면서 전체 일의 순서를 짜는 알고리즘입니다.
만약 아래와 같은 일의 순서를 각각 지키면서 전체 일의 순서를 정한다면

1 4 //1번일을 하고 난 후 4번일을 해야한다.
5 4
4 3
2 5
2 3
6 2

전체 일의 순서는 1, 6, 2, 5, 4, 3과 같이 정할 수 있다. 
전체 일의 순서는 여러 가지가 있습니다 그 중에 하나입니다.

▣ 입력설명
첫 번째 줄에 전체 일의 개수 N과 일의 순서 정보의 개수 M이 주어집니다. 
두 번째 줄부터 M개의 정보가 주어집니다.

▣ 출력설명
전체 일의 순서를 출력합니다.

▣ 입력예제 1 
6 6
1 4
5 4
4 3
2 5 
2 3 
6 2

▣ 출력예제 1 
1 6 2 5 4 3


- 설명
4번 노드를 보면 연결된 간선이 총 3개이다.(1, 5, 3번 노드) 이를 차수가 3개인 노드라고 한다.
그 중 1번, 5번노드는 4번 방향으로 진입하는 간선이다.
이를 진입 차수라고 하는데, 진입 차수의 노드들의 작업이 다 끝나야지만 해당 노드의 작업을 할 수 있다.
4번 노드는 진입차수가 2개.


'''
import sys
from collections import deque

n, m = map(int, sys.stdin.readline().split())
graph = [[0] * (n+1) for _ in range(n+1)] # 행 index -> 열 index
degree = [0] * (n+1)
for i in range(m):
    a, b = map(int, sys.stdin.readline().rstrip().split())
    graph[a][b] = 1
    degree[b] += 1 # 각 노드의 진입 차수를 계산

q = deque()
for i in range(1, n+1):
    if degree[i] == 0: # 진입차수가 0인 노드를 queue에 넣는다
        q.append(i)

# 진입차수가 0인 노드를 큐에서 지우면서(=작업을 처리함을 의미) 
# 그 노드가 진입차수로 있던 노드의 degree를 하나 감소시킨다
while q:
    x = q.popleft()
    print(x, end=' ')
    for i in range(1, n+1):
        if graph[x][i] == 1: # x노드에서 연결된 노드가 있다면 그 노드의 진입차수에서 -1하기 
            degree[i] -= 1
            if degree[i] == 0:
                q.append(i)

